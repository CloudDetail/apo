// Copyright 2025 CloudDetail
// SPDX-License-Identifier: Apache-2.0

package incident

import (
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/CloudDetail/apo/backend/pkg/core"
	"github.com/CloudDetail/apo/backend/pkg/model/integration/alert"
	"github.com/google/uuid"
)

type IncidentMemCache struct {
	// Source -> IncidentTemps
	Temps map[string][]alert.IncidentKeyTemp

	// IncidentKey -> Incident
	Incidents map[string]*alert.Incident

	iMutex sync.RWMutex

	createHandler CreateIncidentFunc
	updateHandler UpdateIncidentFunc
}

type CreateIncidentFunc func(ctx core.Context, incident *alert.Incident, event *alert.AlertEvent) error

type UpdateIncidentFunc func(
	ctx core.Context, incident *alert.Incident, event *alert.AlertEvent) error

func NewIncidentMemCache(incidents []alert.Incident, temps []alert.IncidentKeyTemp) *IncidentMemCache {
	var tempMap = make(map[string][]alert.IncidentKeyTemp)
	for i := 0; i < len(temps); i++ {
		tempMap[temps[i].AlertSourceID] = append(tempMap[temps[i].AlertSourceID], temps[i])
	}

	return &IncidentMemCache{
		Temps:     tempMap,
		Incidents: make(map[string]*alert.Incident),
	}
}

func (c *IncidentMemCache) OnCreate(handler CreateIncidentFunc) *IncidentMemCache {
	c.createHandler = handler
	return c
}

func (c *IncidentMemCache) OnUpdate(handler UpdateIncidentFunc) *IncidentMemCache {
	c.updateHandler = handler
	return c
}

func (c *IncidentMemCache) HandlerAlertEvents(ctx core.Context, events []alert.AlertEvent) error {
	var errs []error
	for i := 0; i < len(events); i++ {
		event := events[i]

		temps := c.Temps[event.SourceID]
		if len(temps) == 0 {
			continue
		}

		groupKey, err := incidentKey(temps, event)
		if err != nil {
			errs = append(errs, fmt.Errorf("failed to generate incident key: %s", err.Error()))
			continue
		}

		c.handlerAlertEvent(ctx, groupKey, event)
	}
	return errors.Join(errs...)
}

func incidentKey(temps []alert.IncidentKeyTemp, event alert.AlertEvent) (string, error) {
	data := map[string]any{
		"payload":   event.Payload(),
		"rawLabels": event.Tags,
		"labels":    event.EnrichTags,
	}
	for j := 0; j < len(temps); j++ {
		if ok, _ := temps[j].CheckConditions(data); !ok {
			continue
		}
		return temps[j].GenerateIncidentKey(data)
	}
	return event.AlertID, nil
}

func (c *IncidentMemCache) handlerAlertEvent(ctx core.Context, groupKey string, event alert.AlertEvent) {
	c.iMutex.Lock()
	defer c.iMutex.Unlock()

	incident, find := c.Incidents[groupKey]
	if !find {
		if event.Status == alert.StatusResolved { // Ignore resolved event if incident not found
			return
		}
		c.CreateIncident(ctx, groupKey, event)
		return
	}

	c.UpdateIncident(ctx, groupKey, incident, &event)
}

func (c *IncidentMemCache) CreateIncident(ctx core.Context, groupKey string, event alert.AlertEvent) {
	incident := alert.Incident{
		ID:           uuid.New().String(), // TODO choose a better id
		Desc:         "Auto generated by APO",
		IncidentKey:  groupKey,
		Status:       alert.StatusFiring,
		CreateTime:   event.UpdateTime.UnixMicro(),
		UpdateTime:   event.UpdateTime.UnixMicro(),
		ResolvedTime: 0,
		AlertEvents: []alert.AlertEvent{
			event,
		},
	}
	c.Incidents[groupKey] = &incident
	go c.createHandler(ctx, &incident, &event) // notify/store
}

func (c *IncidentMemCache) UpdateIncident(
	ctx core.Context,
	groupKey string,
	incident *alert.Incident,
	event *alert.AlertEvent,
) {
	incident.AlertEvents = append(incident.AlertEvents, *event)
	incident.UpdateTime = event.UpdateTime.UnixMicro()
	go c.updateHandler(ctx, incident, event) // notify/store
}

func (c *IncidentMemCache) KeepClean(ctx core.Context) {
	ticker := time.NewTicker(60 * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-ticker.C:
			c.autoResolvedIncidents(ctx)
		case <-ctx.Done():
			return
		}
	}
}

func (c *IncidentMemCache) autoResolvedIncidents(ctx core.Context) {
	c.iMutex.Lock()
	defer c.iMutex.Unlock()

	nowTs := time.Now().UnixMicro()

	toRemoved := []string{}
	for k, incident := range c.Incidents {
		if incident.UpdateTime+5*60*1e6 > nowTs {
			continue
		}

		if incident.GetFiringAlertCount() > 0 {
			continue
		}

		toRemoved = append(toRemoved, k)

		incident.Status = alert.StatusResolved
		incident.ResolvedTime = nowTs
		go c.updateHandler(ctx, incident, nil)
	}

	for i := 0; i < len(toRemoved); i++ {
		delete(c.Incidents, toRemoved[i])
	}
}
